#include <stdio.h>

// Structure to hold item information
struct Item {
    int id;
    int weight;
    int value;
};

// Global variables
struct Item items[10];
int solution[10];  // 0 or 1 for each item
int n;
float capacity;

// Calculate value-to-weight ratio for a given item
float getRatio(struct Item it) {
    if (it.weight == 0) return 0; // Avoid division by zero, though weights should be positive
    return (float)it.value / it.weight;
}

// Sort items by ratio (highest first) using Bubble Sort
void sortByRatio() {
    int i, j;
    for (i = 0; i < n - 1; i++) {
        for (j = 0; j < n - i - 1; j++) {
            if (getRatio(items[j]) < getRatio(items[j + 1])) {
                // Swap items
                struct Item temp = items[j];
                items[j] = items[j + 1];
                items[j + 1] = temp;
            }
        }
    }
}

int main() {
    int i;
    float totalProfit = 0;
    float remainingCapacity;

    printf("=== GREEDY KNAPSACK PROBLEM ===\n");

    // Get input
    printf("Enter number of items: ");
    scanf("%d", &n);

    if (n > 10 || n < 0) {
        printf("Number of items must be between 0 and 10.\n");
        return 1;
    }

    printf("Enter items (id weight value):\n");
    for (i = 0; i < n; i++) {
        scanf("%d %d %d", &items[i].id, &items[i].weight, &items[i].value);
    }

    printf("Enter knapsack capacity: ");
    scanf("%f", &capacity);
    remainingCapacity = capacity;

    // Sort items by value-to-weight ratio
    sortByRatio();

    // Initialize solution array
    for (i = 0; i < n; i++) {
        solution[i] = 0;
    }

    // Greedy selection
    for (i = 0; i < n; i++) {
        if (items[i].weight <= remainingCapacity) {
            remainingCapacity -= items[i].weight;
            solution[i] = 1; // Mark item as taken (based on sorted order)
            totalProfit += items[i].value;
        }
    }

    // Display results
    // Note: The solution array corresponds to the sorted items.
    // To show solution for original item IDs, more complex tracking or re-mapping is needed.
    // The current code shows 0/1 for items in their sorted (by ratio) order.
    printf("\nResult vector (0/1 for each item in sorted order):\n");
    for (i = 0; i < n; i++) {
        // To link back to original item ID, one might store original index or print item[i].id
        printf("Item with original ID %d (Weight: %d, Value: %d, Ratio: %.2f): %d\n",
               items[i].id, items[i].weight, items[i].value, getRatio(items[i]), solution[i]);
    }

    printf("Maximum profit: %.2f\n", totalProfit);

    return 0;
}